C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE DMP
OBJECT MODULE PLACED IN .\Objects\DMP.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE DMP.c LARGE INTR2 ROM(HUGE) BROWSE DEBUG PRINT(.\Listings\DMP.lst) OBJ
                    -ECT(.\Objects\DMP.obj) 

stmt  level    source

    1          /*****************************************************
    2          功能:   采集MPU6050 DMP 数据
    3          CPU:    STC89C52Rc
    4          晶震:   11.0592
    5          语言:   c
    6          来源：  移植 Jeff Jrowberg 公开的程序。
    7          目的：
    8          sda 或则scl 为高时是:释放总线
    9          *****************************************************/
   10          #include "Soft_I2C.h"
   11          #include "MPU6050.h"
   12          
   13          float Q[4];     //四元数
   14          
   15          uint8_t dmpdatas[42];   //DMP数据
   16          
   17          //以下的 firmware 及 config update 数据来自于 Jeff Jrowberg 公开的程序
   18          /* ================================================================================================ *
   19          | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
   20          |                                                                                                  |
   21          | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
   22          |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
   23          |                                                                                                  |
   24          | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
   25          |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
   26          * ================================================================================================ */
   27          uint8_t code dmpmemorydata[1929] = 
   28          {
   29                  // bank 0, 256 bytes
   30                  0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
   31                  0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
   32                  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   33                  0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
   34                  0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
   35                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   36                  0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
   37                  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
   38                  0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
   39                  0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
   40                  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
   41                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
   42                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   43                  0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
   44                  0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
   45                  0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
   46                  // bank 1, 256 bytes
   47                  0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   48                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
   49                  0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
   50                  0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
   51                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
   52                  0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
   53                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
   54                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   55                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   56                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   57                  0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
   58                  0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 2   

   59                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
   60                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   61                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   62                  0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
   63                  // bank 2, 256 bytes
   64                  0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   65                  0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
   66                  0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
   67                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   68                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   69                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   70                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   71                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   72                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   73                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   74                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   75                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
   76                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   77                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   78                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   79                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   80                  // bank 3, 256 bytes
   81                  0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
   82                  0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
   83                  0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
   84                  0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
   85                  0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
   86                  0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
   87                  0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
   88                  0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
   89                  0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
   90                  0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
   91                  0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
   92                  0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
   93                  0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
   94                  0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
   95                  0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
   96                  0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
   97                  // bank 4, 256 bytes
   98                  0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
   99                  0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
  100                  0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
  101                  0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
  102                  0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
  103                  0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
  104                  0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
  105                  0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
  106                  0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
  107                  0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
  108                  0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
  109                  0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
  110                  0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
  111                  0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
  112                  0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
  113                  0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
  114                  // bank 5, 256 bytes
  115                  0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
  116                  0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
  117                  0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
  118                  0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
  119                  0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
  120                  0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
  121                  0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
  122                  0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
  123                  0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
  124                  0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 3   

  125                  0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
  126                  0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
  127                  0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
  128                  0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
  129                  0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
  130                  0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
  131                  // bank 6, 256 bytes
  132                  0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
  133                  0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
  134                  0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
  135                  0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
  136                  0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
  137                  0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
  138                  0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
  139                  0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
  140                  0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
  141                  0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
  142                  0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
  143                  0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
  144                  0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
  145                  0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
  146                  0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
  147                  0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
  148                  // bank 7, 138 bytes (remainder)
  149                  0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
  150                  0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
  151                  0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
  152                  0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
  153                  0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
  154                  0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
  155                  0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
  156                  0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
  157                  0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
  158          }; 
  159          
  160           uint8_t code dmpcfgupddata[192] = 
  161          {
  162          //  dmp config 
  163          //  BANK    OFFSET  LENGTH  [DATA]
  164                  0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,
  165                  0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,
  166                  0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,
  167                  0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,
  168                  0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,
  169                  0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
  170                  0x03,   0x89,   0x03,   0x26, 0x46, 0x66,
  171                  0x00,   0x6C,   0x02,   0x20, 0x00,
  172                  0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,
  173                  0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,
  174                  0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,
  175                  0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,
  176                  0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,
  177                  0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,
  178                  0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,
  179                  0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,
  180                  0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,
  181                  0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,
  182                  0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
  183                  0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,
  184                  0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,
  185                  0x00,   0xA3,   0x01,   0x00,
  186                  0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的
  187                  //原程序中此行代码为(这里不一定错)
  188                  //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错
  189                  0x07,   0x86,   0x01,   0xFE,
  190                  0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 4   

  191                  0x07,   0x7E,   0x01,   0x30,
  192                  0x07,   0x46,   0x01,   0x9A,
  193                  0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,
  194                  0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,
  195                  0x02,   0x16,   0x02,   0x00, 0x01,
  196                  /* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,
  197                  // 可从 datasheet 公式推算
  198                  //dmp updates
  199                  0x01,   0xB2,   0x02,   0xFF, 0xFF,
  200                  0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
  201                  0x01,   0x6A,   0x02,   0x06, 0x00,
  202                  0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  203                  0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
  204                  0x01,   0x62,   0x02,   0x00, 0x00,
  205                  0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/
  206          };
  207          
  208           uint8_t code dmpUpdates[47] = 
  209          {
  210                  0x01,   0xB2,   0x02,   0xFF, 0xFF,
  211                  0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
  212                  0x01,   0x6A,   0x02,   0x06, 0x00,
  213                  0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  214                  0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
  215                  0x01,   0x62,   0x02,   0x00, 0x00,
  216                  0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
  217          
  218          };
  219          
  220          /*
  221          加载 DMP代码到
  222          返回值  (1=成功,0=失败)
  223          */
  224          uint8_t loadfirmware(void)
  225          {
  226   1              uint16_t datanum = 0;   //DMP固件写入标志位
  227   1              uint8_t ye, i/*, j*/;
  228   1              uint8_t bank = 0;       //段（256个数据一段）
  229   1              uint8_t addr = 0;
  230   1      
  231   1              for (; bank<8; bank++)
  232   1              {
  233   2                      if (bank == 7)  //这里的作用就是区分最后一段数据
  234   2                              i = 8;
  235   2                      else
  236   2                              i = 16;
  237   2                      for (ye = 0; ye<i; ye++)
  238   2                      {
  239   3                              MPU_Write_Byte(0x6d, bank);
  240   3                              MPU_Write_Byte(0x6e, addr);
  241   3                              MPU_Write_Len(0x6f, 16, dmpmemorydata + datanum);
  242   3                              datanum += 16;
  243   3                              addr += 16;
  244   3                      }
  245   2              }
  246   1              MPU_Write_Byte(0x6d, 7);
  247   1              MPU_Write_Byte(0x6e, addr);
  248   1              MPU_Write_Len(0x6f, 9, dmpmemorydata + datanum);
  249   1              datanum += 9;
  250   1              return 1;
  251   1      }
  252          
  253          uint8_t loadcfgupd(void)        //DMP设置
  254          {
  255   1              uint8_t line;   //一共需要写入30条设置数据
  256   1              uint8_t bank;   //页
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 5   

  257   1              uint8_t datacounts = 0; //DMP设置数据标志位
  258   1              uint8_t bytes2write;    //数据长度。
  259   1              uint8_t offset; //偏移地址
  260   1              uint8_t writingcounts;  //数据写入标志与bytes2write一同使用
  261   1              uint8_t special;
  262   1      
  263   1              for (line = 0; line<30; line++)
  264   1              {
  265   2                      bank = dmpcfgupddata[datacounts++];
  266   2                      offset = dmpcfgupddata[datacounts++];
  267   2                      bytes2write = dmpcfgupddata[datacounts++];
  268   2                      MPU_Write_Byte(0x6d, bank);
  269   2                      MPU_Write_Byte(0x6e, offset);
  270   2                      MPU_Write_Len(0x6f, bytes2write, dmpcfgupddata + datacounts);
  271   2                      writingcounts = bytes2write;
  272   2                      datacounts += bytes2write;
  273   2                      if (0 == bytes2write)
  274   2                      {
  275   3                              special = dmpcfgupddata[datacounts++];
  276   3                              if (0x01 == special)
  277   3                              {
  278   4                                      //设置零运动中断启用（真）;
  279   4                                      //设置FIFO缓冲区溢出启用（真）;
  280   4                                      //设置DMP启用（真）;
  281   4                                      MPU_Write_Byte(MPU_INT_EN_REG, 0x32);
  282   4                              }
  283   3                              else
  284   3                                      return 0;
  285   3                      }
  286   2              }
  287   1              return 1;
  288   1      }
  289          
  290          /*最后更新DMP*/
  291          uint8_t xdmpUpdates(uint8_t datacounts)
  292          {
  293   1              uint8_t writingcounts, bank, offset, bytes2write;
  294   1              bank = dmpUpdates[datacounts++];
  295   1              offset = dmpUpdates[datacounts++];
  296   1              bytes2write = dmpUpdates[datacounts++];
  297   1              MPU_Write_Byte(0x6d, bank);
  298   1              MPU_Write_Byte(0x6e, offset);
  299   1              MPU_Write_Len(0x6f, bytes2write, dmpUpdates + datacounts);
  300   1              writingcounts = bytes2write;
  301   1              datacounts += bytes2write;
  302   1              return 1;
  303   1      }
  304          
  305          /*读取 FIFO 计数*/
  306          uint16_t getFIFOCount()
  307          {
  308   1              uint8_t i[2];
  309   1              MPU_Read_Len(MPU_FIFO_CNTH_REG, 2, i);
  310   1              return ((i[0] << 8) + i[1]);
  311   1      }
  312          
  313          /*FIFO数据读取
  314          参数 *Data      存储数据的地址
  315          返回值 (1=读取成功,0读取失败)
  316          */
  317          uint8_t readdmp(uint8_t *Data)
  318          {
  319   1              return !MPU_Read_Len(MPU_FIFO_RW_REG, 42, Data);
  320   1      }
  321          
  322          //加载并配置 DMP 数字运动处理引擎
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 6   

  323          uint8_t dmpInitialize(void)
  324          {
  325   1              uint8_t hwRevision, otpValid, mpuIntStatus/*fifoBuffer[128]*/;
  326   1              uint8_t xgOffsetTC, ygOffsetTC, zgOffsetTC;
  327   1              uint16_t fifoCount;
  328   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 7, 1); //复位 MPU6050
  329   1              MPU_Delay_Ms(30);
  330   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 0); //禁止睡眠模式
  331   1              MPU_Write_Byte(0x6D, 0x70);     //写入一个字节数据到0x6d寄存器(选择用户 bank)
  332   1              MPU_Write_Byte(0x6E, 0x06);     //写入一个字节数据到0x6e寄存器(选择存储字节)
  333   1              MPU_Read_Len(0x6F, 1, &hwRevision);     //读取 
  334   1              MPU_Write_Byte(0x6D, 0);        //重置内存 bank 选择
  335   1              MPU_Read_Bit(0x00, 0, &otpValid);       //读取 OTP bank 有效标志
  336   1              MPU_Read_Bits(0x00, 6, 6, &xgOffsetTC); //读陀螺偏置TC值 X
  337   1              MPU_Read_Bits(0x01, 6, 6, &ygOffsetTC); //读陀螺偏置TC值 Y)
  338   1              MPU_Read_Bits(0x02, 6, 6, &zgOffsetTC); //读陀螺偏置TC值 Z
  339   1              //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x7f);    //设置从0地址 0x7
  340   1              //MPU_Write_Bit(MPU_USER_CTRL_REG,5,0); //禁用I2C主模式
  341   1              //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x68);    //这里可能要改。还没有弄明白这里
  342   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 1, 1); //I2C总线主控复位
  343   1              MPU_Delay_Ms(20);
  344   1              if ((loadfirmware()) == 0) 
  345   1                      return 0;       //加载 
  346   1              if ((loadcfgupd()) == 0) 
  347   1                      return 0;       //配置DMP
  348   1              MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x03);  //设置时钟脉冲源Z陀螺
  349   1              MPU_Write_Byte(MPU_INT_EN_REG, 0x12);   //设置DMP和FIFO_OFLOW启用中断
  350   1              MPU_Write_Byte(MPU_SAMPLE_RATE_REG, 4); //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)
  351   1              MPU_Write_Bits(MPU_CFG_REG, 5, 3, 0x1); //设置外部帧同步TEMP_OUT_L[0]
  352   1              MPU_Write_Bits(MPU_CFG_REG, 2, 3, 0x03);        //设置DLPF带宽42赫兹
  353   1              MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x03);   //陀螺灵敏度设置为+ / - 2000 deg/sec
  354   1              MPU_Write_Byte(0x70, 0x03);     //设置DMP配置字节（功能未知）
  355   1              MPU_Write_Byte(0x71, 0x00);     //设置DMP配置字节（功能未知）
  356   1              MPU_Write_Bit(0x00, 0, 0);      //清除OTP Bank 标志
  357   1              MPU_Write_Bits(0x00, 6, 6, 0);  //设置X 陀螺抵消TCs之前的值
  358   1              MPU_Write_Bits(0x01, 6, 6, 0);  //设置Y 陀螺抵消TCs之前的值
  359   1              MPU_Write_Bits(0x02, 6, 6, 0);  //设置Z 陀螺抵消TCs之前的值
  360   1              if (xdmpUpdates(0) == 0) 
  361   1                      return 0;       //最后更新1/7(函数未知)dmpUpdates数组第一行
  362   1              if (xdmpUpdates(5) == 0) 
  363   1                      return 0;       //最后更新2/7(函数未知)dmpUpdates数组第二行
  364   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  365   1              fifoCount = getFIFOCount();     //读取 FIFO 计数
  366   1                                                                      //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  367   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  368   1      
  369   1              MPU_Write_Byte(MPU_MOTION_DET_REG, 2);  //运动检测阈值设置为2
  370   1              MPU_Write_Byte(0x21, 156);      //零运动检测阈值为156
  371   1              MPU_Write_Byte(0x20, 80);       //设置运动检测持续时间至80
  372   1              MPU_Write_Byte(0x22, 0);        //设置零运动检测时间0
  373   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复 位 FIFO
  374   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 6, 1); //使能 FIFO
  375   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1); //使能 DMP
  376   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 3, 1); //复位 DMP
  377   1              if (xdmpUpdates(12) == 0) 
  378   1                      return 0;       //最后更新3/7(函数未知)dmpUpdates数组第三行
  379   1              if (xdmpUpdates(17) == 0) 
  380   1                      return 0;       //最后更新4/7(函数未知)dmpUpdates数组第四行
  381   1              if (xdmpUpdates(28) == 0) 
  382   1                      return 0;       //最后更新5/7(函数未知)dmpUpdates数组第五行
  383   1              while ((fifoCount = getFIFOCount()) < 3);       //等待 FIFO 计数 > 2
  384   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);                 //复位 FIFO
  385   1              //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  386   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);                //读取中断状态
  387   1              if (xdmpUpdates(35) == 0) 
  388   1                      return 0;       //最后更新6/7(函数未知)dmpUpdates数组第六行
C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 7   

  389   1              while ((fifoCount = getFIFOCount()) < 3);       //等待 FIFO 计数 > 2
  390   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  391   1              //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  392   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);        //读取中断状态
  393   1              if (xdmpUpdates(40) == 0) 
  394   1                      return 0;       //最后更新7/7(函数未知)dmpUpdates数组第七行
  395   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 0); //禁用DMP(稍后您打开它)
  396   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  397   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);
  398   1              //星期六 (2014/06/28)
  399   1              return 1;
  400   1      }
  401          
  402          /*初始化MPU6050*/
  403          void initMPU6050(void)
  404          {
  405   1              MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x01);  //电源管理
  406   1              MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x00);   //设置陀螺仪量程 250/s
  407   1              MPU_Write_Bits(MPU_ACCEL_CFG_REG, 4, 2, 0x00);  //设置加速度量程 2G
  408   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 1); //电源管理MUP进入睡眠模式
  409   1      }
  410          
  411          /*验证MPU6050连接*/
  412          uint8_t getDeviceID(void)
  413          {
  414   1              uint8_t b = 0;  //临时变量
  415   1              MPU_Read_Bits(MPU_DEVICE_ID_REG, 6, 6, &b);     //读取i2c固定地址，去掉最高位和最低位这两位数据
  416   1              return b == 0x34;       //判断B是否等于0x34，如果等于返回1，不等于返回0(库的是0x38)
  417   1      
  418   1      }
  419          
  420          void MPU6050_DMP_Init(void)
  421          {
  422   1              initMPU6050();  //初始化
  423   1              if (getDeviceID())      //验证连接是否正常(读取MPU6050的I2C地址)
  424   1                      while(!(dmpInitialize()));      //加载并配置运动库
  425   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  426   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1); //使能DMP
  427   1      }
  428          
  429          void MPU6050_Refresh_DMP(void)
  430          {
  431   1              static uint8_t zd;
  432   1              static uint16_t i;
  433   1              i = getFIFOCount();//读取FIFO计数
  434   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &zd);  //读取中断状态
  435   1              if ((zd & 0x10) || i >= 840)    //判断FIFO是否溢出
  436   1              {
  437   2                      MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  438   2              }
  439   1              else if (zd & 0x02)
  440   1              {
  441   2                      while (i<42) 
  442   2                              i = getFIFOCount();
  443   2                      if (readdmp(dmpdatas))  //读取FIFO数据
  444   2                      {
  445   3                              Q[0] = ((int16_t)dmpdatas[0] << 8 | dmpdatas[1])/16384.;
  446   3                              Q[1] = ((int16_t)dmpdatas[4] << 8 | dmpdatas[5])/16384.;
  447   3                              Q[2] = ((int16_t)dmpdatas[8] << 8 | dmpdatas[9])/16384.;
  448   3                              Q[3] = ((int16_t)dmpdatas[12] << 8 | dmpdatas[13])/16384.;
  449   3                      }
  450   2              }
  451   1      }
  452          


C251 COMPILER V5.60.0,  DMP                                                                29/07/23  15:18:34  PAGE 8   

Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2168     ------
  ecode size           =      1485     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        61         13
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
