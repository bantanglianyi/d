C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE STC32G_PWM
OBJECT MODULE PLACED IN .\Objects\STC32G_PWM.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE STC32G_PWM.c LARGE INTR2 BROWSE DEBUG PRINT(.\Listings\STC32G_PWM.lst)
                    - OBJECT(.\Objects\STC32G_PWM.obj) 

stmt  level    source

    1          #include "STC32G_PWM.h"
    2          
    3          #define sys_clk 24000000//22118400                                                                      //系统频率
    4          #define freqA 56745                                                                     //A通道pwm频率
    5          #define freqA_div ((sys_clk / freqA) >> 15)                             //自动计算A通道分频系数
    6          #define PWMA_period (sys_clk / freqA / (freqA_div + 1)) //自动计算A通道计算周期
    7          //#define PWMA_period   6000    //定义PWMA周期 0~65535
    8          //#define freqA_div 0                   //定义周期时不需要分频或者手动输入
    9          
   10          #define freqB 1                                                                 //B通道pwm频率
   11          #define freqB_div ((sys_clk / freqB) >> 15)                             //自动计算B通道分频系数
   12          #define PWMB_period (sys_clk / freqB / (freqB_div + 1)) //自动计算B通道计算周期
   13          //#define PWMB_period   65535   //定义PWMB周期 0~65535
   14          //#define freqB_div 0                   //定义周期时不需要分频或者手动输入
   15          
   16          u8 PWM_Configuration(u8 PWM, PWMx_InitDefine *PWMx)     //PWM初始化函数
   17          {
   18   1              if(PWM == PWM1)
   19   1              {
   20   2                      PWMA_CC1E_Disable();            //关闭输入捕获/比较输出
   21   2                      PWMA_CC1NE_Disable();           //关闭比较输出
   22   2                      PWMA_CC1S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
   23   2                      PWMA_OC1ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
   24   2      
   25   2                      if(PWMx->PWM_EnoSelect & ENO1P)
   26   2                      {
   27   3                              PWMA_CC1E_Enable();                     //开启输入捕获/比较输出
   28   3                              PWMA_ENO |= ENO1P;
   29   3                      }
   30   2                      else
   31   2                      {
   32   3                              PWMA_CC1E_Disable();            //关闭输入捕获/比较输出
   33   3                              PWMA_ENO &= ~ENO1P;
   34   3                      }
   35   2                      if(PWMx->PWM_EnoSelect & ENO1N)
   36   2                      {
   37   3                              PWMA_CC1NE_Enable();            //开启输入捕获/比较输出
   38   3                              PWMA_ENO |= ENO1N;
   39   3                      }
   40   2                      else
   41   2                      {
   42   3                              PWMA_CC1NE_Disable();           //关闭输入捕获/比较输出
   43   3                              PWMA_ENO &= ~ENO1N;
   44   3                      }
   45   2                      PWMA_Duty1(PWMx->PWM_Duty);
   46   2                      return  SUCCESS;
   47   2              }
   48   1              
   49   1              if(PWM == PWM2)
   50   1              {
   51   2                      PWMA_CC2E_Disable();            //关闭输入捕获/比较输出
   52   2                      PWMA_CC2NE_Disable();           //关闭比较输出
   53   2                      PWMA_CC2S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
   54   2                      PWMA_OC2ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
   55   2      
   56   2                      if(PWMx->PWM_EnoSelect & ENO2P)
   57   2                      {
   58   3                              PWMA_CC2E_Enable();                     //开启输入捕获/比较输出
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 2   

   59   3                              PWMA_ENO |= ENO2P;
   60   3                      }
   61   2                      else
   62   2                      {
   63   3                              PWMA_CC2E_Disable();            //关闭输入捕获/比较输出
   64   3                              PWMA_ENO &= ~ENO2P;
   65   3                      }
   66   2                      if(PWMx->PWM_EnoSelect & ENO2N)
   67   2                      {
   68   3                              PWMA_CC2NE_Enable();            //开启输入捕获/比较输出
   69   3                              PWMA_ENO |= ENO2N;
   70   3                      }
   71   2                      else
   72   2                      {
   73   3                              PWMA_CC2NE_Disable();           //关闭输入捕获/比较输出
   74   3                              PWMA_ENO &= ~ENO2N;
   75   3                      }
   76   2                      PWMA_Duty2(PWMx->PWM_Duty);
   77   2                      return  SUCCESS;
   78   2              }
   79   1              
   80   1              if(PWM == PWM3)
   81   1              {
   82   2                      PWMA_CC3E_Disable();            //关闭输入捕获/比较输出
   83   2                      PWMA_CC3NE_Disable();           //关闭比较输出
   84   2                      PWMA_CC3S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
   85   2                      PWMA_OC3ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
   86   2      
   87   2                      if(PWMx->PWM_EnoSelect & ENO3P)
   88   2                      {
   89   3                              PWMA_CC3E_Enable();                     //开启输入捕获/比较输出
   90   3                              PWMA_ENO |= ENO3P;
   91   3                      }
   92   2                      else
   93   2                      {
   94   3                              PWMA_CC3E_Disable();            //关闭输入捕获/比较输出
   95   3                              PWMA_ENO &= ~ENO3P;
   96   3                      }
   97   2                      if(PWMx->PWM_EnoSelect & ENO3N)
   98   2                      {
   99   3                              PWMA_CC3NE_Enable();            //开启输入捕获/比较输出
  100   3                              PWMA_ENO |= ENO3N;
  101   3                      }
  102   2                      else
  103   2                      {
  104   3                              PWMA_CC3NE_Disable();           //关闭输入捕获/比较输出
  105   3                              PWMA_ENO &= ~ENO3N;
  106   3                      }
  107   2                      PWMA_Duty3(PWMx->PWM_Duty);
  108   2                      return  SUCCESS;
  109   2              }
  110   1              
  111   1              if(PWM == PWM4)
  112   1              {
  113   2                      PWMA_CC4E_Disable();            //关闭输入捕获/比较输出
  114   2                      PWMA_CC4NE_Disable();           //关闭比较输出
  115   2                      PWMA_CC4S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
  116   2                      PWMA_OC4ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
  117   2      
  118   2                      if(PWMx->PWM_EnoSelect & ENO4P)
  119   2                      {
  120   3                              PWMA_CC4E_Enable();                     //开启输入捕获/比较输出
  121   3                              PWMA_ENO |= ENO4P;
  122   3                      }
  123   2                      else
  124   2                      {
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 3   

  125   3                              PWMA_CC4E_Disable();            //关闭输入捕获/比较输出
  126   3                              PWMA_ENO &= ~ENO4P;
  127   3                      }
  128   2                      if(PWMx->PWM_EnoSelect & ENO4N)
  129   2                      {
  130   3                              PWMA_CC4NE_Enable();            //开启输入捕获/比较输出
  131   3                              PWMA_ENO |= ENO4N;
  132   3                      }
  133   2                      else
  134   2                      {
  135   3                              PWMA_CC4NE_Disable();           //关闭输入捕获/比较输出
  136   3                              PWMA_ENO &= ~ENO4N;
  137   3                      }
  138   2                      PWMA_Duty4(PWMx->PWM_Duty);
  139   2                      return  SUCCESS;
  140   2              }
  141   1              
  142   1              if(PWM == PWMA)
  143   1              {
  144   2      //              PWMA_OC1_ReloadEnable(PWMx->PWM_Reload);        //输出比较的预装载使能
  145   2      //              PWMA_OC1_FastEnable(PWMx->PWM_Fast);            //输出比较快速功能使能
  146   2      //              PWMA_CCPCAPreloaded(PWMx->PWM_PreLoad); //捕获/比较预装载控制位(该位只对具有互补输出的通道起作用)
  147   2      //              PWMA_BrakeEnable(PWMx->PWM_BrakeEnable);        //开启/禁止刹车输入
  148   2      
  149   2                      PWMA_DeadTime(PWMx->PWM_DeadTime);      //死区发生器设置
  150   2                      PWMA_AutoReload(PWMx->PWM_Period);      //周期设置
  151   2                      PWMA_BrakeOutputEnable(PWMx->PWM_MainOutEnable);        //主输出使能
  152   2                      PWMA_CEN_Enable(PWMx->PWM_CEN_Enable);  //使能计数器
  153   2                      return  SUCCESS;
  154   2              }
  155   1      
  156   1              if(PWM == PWM5)
  157   1              {
  158   2                      PWMB_CC5E_Disable();            //关闭输入捕获/比较输出
  159   2                      PWMB_CC5S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
  160   2                      PWMB_OC5ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
  161   2      
  162   2                      if(PWMx->PWM_EnoSelect & ENO5P)
  163   2                      {
  164   3                              PWMB_CC5E_Enable();                     //开启输入捕获/比较输出
  165   3                              PWMB_ENO |= ENO5P;
  166   3                      }
  167   2                      else
  168   2                      {
  169   3                              PWMB_CC5E_Disable();            //关闭输入捕获/比较输出
  170   3                              PWMB_ENO &= ~ENO5P;
  171   3                      }
  172   2                      PWMB_Duty5(PWMx->PWM_Duty);
  173   2                      return  SUCCESS;
  174   2              }
  175   1              
  176   1              if(PWM == PWM6)
  177   1              {
  178   2                      PWMB_CC6E_Disable();            //关闭输入捕获/比较输出
  179   2                      PWMB_CC6S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
  180   2                      PWMB_OC6ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
  181   2      
  182   2                      if(PWMx->PWM_EnoSelect & ENO6P)
  183   2                      {
  184   3                              PWMB_CC6E_Enable();                     //开启输入捕获/比较输出
  185   3                              PWMB_ENO |= ENO6P;
  186   3                      }
  187   2                      else
  188   2                      {
  189   3                              PWMB_CC6E_Disable();            //关闭输入捕获/比较输出
  190   3                              PWMB_ENO &= ~ENO6P;
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 4   

  191   3                      }
  192   2                      PWMB_Duty6(PWMx->PWM_Duty);
  193   2                      return  SUCCESS;
  194   2              }
  195   1              
  196   1              if(PWM == PWM7)
  197   1              {
  198   2                      PWMB_CC7E_Disable();            //关闭输入捕获/比较输出
  199   2                      PWMB_CC7S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
  200   2                      PWMB_OC7ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
  201   2      
  202   2                      if(PWMx->PWM_EnoSelect & ENO7P)
  203   2                      {
  204   3                              PWMB_CC7E_Enable();                     //开启输入捕获/比较输出
  205   3                              PWMB_ENO |= ENO7P;
  206   3                      }
  207   2                      else
  208   2                      {
  209   3                              PWMB_CC7E_Disable();            //关闭输入捕获/比较输出
  210   3                              PWMB_ENO &= ~ENO7P;
  211   3                      }
  212   2                      PWMB_Duty7(PWMx->PWM_Duty);
  213   2                      return  SUCCESS;
  214   2              }
  215   1              
  216   1              if(PWM == PWM8)
  217   1              {
  218   2                      PWMB_CC8E_Disable();            //关闭输入捕获/比较输出
  219   2                      PWMB_CC8S_Direction(CCAS_OUTPUT);               //CCnS仅在通道关闭时才是可写的
  220   2                      PWMB_OC8ModeSet(PWMx->PWM_Mode);                //设置输出比较模式
  221   2      
  222   2                      if(PWMx->PWM_EnoSelect & ENO8P)
  223   2                      {
  224   3                              PWMB_CC8E_Enable();                     //开启输入捕获/比较输出
  225   3                              PWMB_ENO |= ENO8P;
  226   3                      }
  227   2                      else
  228   2                      {
  229   3                              PWMB_CC8E_Disable();            //关闭输入捕获/比较输出
  230   3                              PWMB_ENO &= ~ENO8P;
  231   3                      }
  232   2                      PWMB_Duty8(PWMx->PWM_Duty);
  233   2                      return  SUCCESS;
  234   2              }
  235   1              
  236   1              if(PWM == PWMB)
  237   1              {
  238   2      //              PWMB_OC5_ReloadEnable(PWMx->PWM_Reload);        //输出比较的预装载使能
  239   2      //              PWMB_OC5_FastEnable(PWMx->PWM_Fast);            //输出比较快速功能使能
  240   2      //              PWMB_CCPCBPreloaded(PWMx->PWM_PreLoad); //捕获/比较预装载控制位(该位只对具有互补输出的通道起作用)
  241   2      //              PWMB_BrakeEnable(PWMx->PWM_BrakeEnable);        //开启/禁止刹车输入
  242   2      
  243   2                      PWMB_DeadTime(PWMx->PWM_DeadTime);      //死区发生器设置
  244   2                      PWMB_AutoReload(PWMx->PWM_Period);      //周期设置
  245   2                      PWMB_BrakeOutputEnable(PWMx->PWM_MainOutEnable);        //主输出使能
  246   2                      PWMB_CEN_Enable(PWMx->PWM_CEN_Enable);  //使能计数器
  247   2                      return  SUCCESS;
  248   2              }
  249   1              return  FALL;   //错误
  250   1      }
  251          
  252          //void UpdatePwm(u8 PWM, PWMx_Duty *PWMx)       //PWM占空比更新程序
  253          //{
  254          //      switch(PWM)
  255          //      {
  256          //              case PWM1:
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 5   

  257          //                      PWMA_Duty1(PWMx->PWM1_Duty);
  258          //                      break;
  259          //              case PWM2:
  260          //                      PWMA_Duty2(PWMx->PWM2_Duty);
  261          //                      break;
  262          //              case PWM3:
  263          //                      PWMA_Duty3(PWMx->PWM3_Duty);
  264          //                      break;
  265          //              case PWM4:
  266          //                      PWMA_Duty4(PWMx->PWM4_Duty);
  267          //                      break;
  268          //              case PWM5:
  269          //                      PWMB_Duty5(PWMx->PWM5_Duty);
  270          //                      break;
  271          //              case PWM6:
  272          //                      PWMB_Duty6(PWMx->PWM6_Duty);
  273          //                      break;
  274          //              case PWM7:
  275          //                      PWMB_Duty7(PWMx->PWM7_Duty);
  276          //                      break;
  277          //              case PWM8:
  278          //                      PWMB_Duty8(PWMx->PWM8_Duty);
  279          //                      break;
  280          //              case PWMA:
  281          //                      PWMA_Duty1(PWMx->PWM1_Duty);
  282          //                      PWMA_Duty2(PWMx->PWM2_Duty);
  283          //                      PWMA_Duty3(PWMx->PWM3_Duty);
  284          //                      PWMA_Duty4(PWMx->PWM4_Duty);
  285          //                      break;
  286          //              case PWMB:
  287          //                      PWMB_Duty5(PWMx->PWM5_Duty);
  288          //                      PWMB_Duty6(PWMx->PWM6_Duty);
  289          //                      PWMB_Duty7(PWMx->PWM7_Duty);
  290          //                      PWMB_Duty8(PWMx->PWM8_Duty);
  291          //                      break;
  292          //              default:break;
  293          //      }
  294          //}
  295          
  296          PWMx_Duty PWMA_Duty,PWMB_Duty;
  297          void PWM_init() //在STC32G_PWM.c中修改配置
  298          {
  299   1              PWMx_InitDefine PWMx_InitStructure;
  300   1              PWMA_Prescaler(freqA_div);      //自动分频
  301   1              PWMB_Prescaler(freqB_div);      //自动分频
  302   1              
  303   1              PWMA_Duty.PWM1_Duty = 128;      //PWM占空比时间, 0~Period
  304   1              PWMA_Duty.PWM2_Duty = 256;      //PWM占空比时间, 0~Period
  305   1              PWMA_Duty.PWM3_Duty = 512;      //PWM占空比时间, 0~Period
  306   1              PWMA_Duty.PWM4_Duty = 1024;     //PWM占空比时间, 0~Period
  307   1              PWMB_Duty.PWM5_Duty = 128;      //PWM占空比时间, 0~Period
  308   1              PWMB_Duty.PWM6_Duty = 256;      //PWM占空比时间, 0~Period
  309   1              PWMB_Duty.PWM7_Duty = 512;      //PWM占空比时间, 0~Period
  310   1              PWMB_Duty.PWM8_Duty = 1024;     //PWM占空比时间, 0~Period
  311   1              //PWMA
  312   1              PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INVAL
             -ID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  313   1              PWMx_InitStructure.PWM_Duty = PWMA_Duty.PWM1_Duty;      //PWM占空比时间, 0~Period
  314   1              PWMx_InitStructure.PWM_EnoSelect = ENO1N|ENO1P;         //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO
             -4P,ENO4N / ENO5P,ENO6P,ENO7P,ENO8P，参数同组可以使用或(|)运算
  315   1              PWM_Configuration(PWM1, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  316   1      
  317   1              PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INVAL
             -ID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  318   1              PWMx_InitStructure.PWM_Duty = PWMA_Duty.PWM2_Duty;      //PWM占空比时间, 0~Period
  319   1              PWMx_InitStructure.PWM_EnoSelect = ENO2P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P,E
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 6   

             -NO4N / ENO5P,ENO6P,ENO7P,ENO8P
  320   1              PWM_Configuration(PWM2, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  321   1      
  322   1              PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INVAL
             -ID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  323   1              PWMx_InitStructure.PWM_Duty = PWMA_Duty.PWM3_Duty;      //PWM占空比时间, 0~Period
  324   1              PWMx_InitStructure.PWM_EnoSelect = ENO3P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P,E
             -NO4N / ENO5P,ENO6P,ENO7P,ENO8P
  325   1              PWM_Configuration(PWM3, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  326   1      
  327   1              PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INVAL
             -ID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  328   1              PWMx_InitStructure.PWM_Duty = PWMA_Duty.PWM4_Duty;      //PWM占空比时间, 0~Period
  329   1              PWMx_InitStructure.PWM_EnoSelect   = ENO4P;                             //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P
             -,ENO4N / ENO5P,ENO6P,ENO7P,ENO8P
  330   1              PWM_Configuration(PWM4, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  331   1      
  332   1              PWMx_InitStructure.PWM_Period = PWMA_period;                    //周期时间,   0~65535   24M--12.5k--1920
  333   1              PWMx_InitStructure.PWM_DeadTime = 0;                                    //死区发生器设置, 0~255         原32usP-48usN -> 设置死区4us -> 28usP-
             --4us低电平--44usN--4us低电平
  334   1              PWMx_InitStructure.PWM_MainOutEnable= ENABLE;                   //主输出使能, ENABLE,DISABLE
  335   1              PWMx_InitStructure.PWM_CEN_Enable = ENABLE;                     //使能计数器, ENABLE,DISABLE
  336   1              PWM_Configuration(PWMA, &PWMx_InitStructure);                   //初始化PWM通用寄存器,  PWMA,PWMB
  337   1              //PWMB
  338   1              PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INVAL
             -ID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  339   1              PWMx_InitStructure.PWM_Duty = PWMB_Duty.PWM5_Duty;      //PWM占空比时间, 0~Period
  340   1              PWMx_InitStructure.PWM_EnoSelect = ENO5P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P,E
             -NO4N / ENO5P,ENO6P,ENO7P,ENO8P
  341   1              PWM_Configuration(PWM5, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  342   1      
  343   1      //      PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INV
             -ALID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  344   1      //      PWMx_InitStructure.PWM_Duty = PWMB_Duty.PWM6_Duty;      //PWM占空比时间, 0~Period
  345   1      //      PWMx_InitStructure.PWM_EnoSelect = ENO6P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P
             -,ENO4N / ENO5P,ENO6P,ENO7P,ENO8P
  346   1      //      PWM_Configuration(PWM6, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  347   1      
  348   1      //      PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INV
             -ALID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  349   1      //      PWMx_InitStructure.PWM_Duty = PWMB_Duty.PWM7_Duty;      //PWM占空比时间, 0~Period
  350   1      //      PWMx_InitStructure.PWM_EnoSelect = ENO7P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P
             -,ENO4N / ENO5P,ENO6P,ENO7P,ENO8P
  351   1      //      PWM_Configuration(PWM7, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  352   1      
  353   1      //      PWMx_InitStructure.PWM_Mode = CCMRn_PWM_MODE1;  //模式,         CCMRn_FREEZE,CCMRn_MATCH_VALID,CCMRn_MATCH_INV
             -ALID,CCMRn_ROLLOVER,CCMRn_FORCE_INVALID,CCMRn_FORCE_VALID,CCMRn_PWM_MODE1,CCMRn_PWM_MODE2
  354   1      //      PWMx_InitStructure.PWM_Duty = PWMB_Duty.PWM8_Duty;      //PWM占空比时间, 0~Period
  355   1      //      PWMx_InitStructure.PWM_EnoSelect = ENO8P;                               //输出通道选择, ENO1P,ENO1N,ENO2P,ENO2N,ENO3P,ENO3N,ENO4P
             -,ENO4N / ENO5P,ENO6P,ENO7P,ENO8P
  356   1      //      PWM_Configuration(PWM8, &PWMx_InitStructure);                   //初始化PWM,  PWMA,PWMB
  357   1      
  358   1              PWMx_InitStructure.PWM_Period = PWMB_period;                    //周期时间,   0~65535
  359   1              PWMx_InitStructure.PWM_DeadTime = 0;                                    //死区发生器设置, 0~255
  360   1              PWMx_InitStructure.PWM_MainOutEnable= ENABLE;                   //主输出使能, ENABLE,DISABLE
  361   1              PWMx_InitStructure.PWM_CEN_Enable = ENABLE;                     //使能计数器, ENABLE,DISABLE
  362   1              PWM_Configuration(PWMB, &PWMx_InitStructure);                   //初始化PWM通用寄存器,  PWMA,PWMB
  363   1              
  364   1      //      PWM1_USE_P60P61();      //引脚却换
  365   1      //      PWM2_USE_P62P63();      //引脚却换
  366   1      //      PWM3_USE_P64P65();      //引脚却换
  367   1      //      PWM4_USE_P66P67();      //引脚却换
  368   1              PWM1_USE_P20P21();
  369   1      //      PWM2_USE_P22P23();
  370   1      //      PWM3_USE_P24P25();
  371   1      //      PWM4_USE_P26P27();
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 7   

  372   1      ////    PWM5_USE_P20(); //引脚却换
  373   1      ////    PWM6_USE_P21(); //引脚却换
  374   1      ////    PWM7_USE_P22(); //引脚却换
  375   1      ////    PWM8_USE_P23(); //引脚却换
  376   1      //      PWM5_USE_P74();
  377   1      //      PWM6_USE_P75();
  378   1      ////    PWM6_USE_P54();
  379   1      //      PWM7_USE_P76();
  380   1      //      PWM8_USE_P77();
  381   1      }
  382          
  383          void HPWM_Set(u8 PWMchannel,float zkb)  //PWMchannel: 1~8       zkb: 0~1
  384          {
  385   1              switch(PWMchannel)
  386   1              {
  387   2                      case PWM1:      //1
  388   2                              PWMA_Duty.PWM1_Duty = zkb*PWMA_period;  //若以1us脉宽形式调整，将PWMA_period改为 PWMA_period*freqA*0.00
             -0001 的值即可
  389   2                              PWMA_Duty1(PWMA_Duty.PWM1_Duty);
  390   2                              break;
  391   2                      case PWM2:
  392   2                              PWMA_Duty.PWM2_Duty = zkb*PWMA_period;
  393   2                              PWMA_Duty2(PWMA_Duty.PWM2_Duty);
  394   2                              break;
  395   2                      case PWM3:
  396   2                              PWMA_Duty.PWM3_Duty = zkb*PWMA_period;
  397   2                              PWMA_Duty3(PWMA_Duty.PWM3_Duty);
  398   2                              break;
  399   2                      case PWM4:
  400   2                              PWMA_Duty.PWM4_Duty = zkb*PWMA_period;
  401   2                              PWMA_Duty4(PWMA_Duty.PWM4_Duty);
  402   2                              break;
  403   2                      case PWM5:
  404   2                              PWMB_Duty.PWM5_Duty = zkb*PWMB_period;
  405   2                              PWMB_Duty5(PWMB_Duty.PWM5_Duty);
  406   2                              break;
  407   2                      case PWM6:
  408   2                              PWMB_Duty.PWM6_Duty = zkb*PWMB_period;
  409   2                              PWMB_Duty6(PWMB_Duty.PWM6_Duty);
  410   2                              break;
  411   2                      case PWM7:
  412   2                              PWMB_Duty.PWM7_Duty = zkb*PWMB_period;
  413   2                              PWMB_Duty7(PWMB_Duty.PWM7_Duty);
  414   2                              break;
  415   2                      case PWM8:
  416   2                              PWMB_Duty.PWM8_Duty = zkb*PWMB_period;
  417   2                              PWMB_Duty8(PWMB_Duty.PWM8_Duty);
  418   2                              break;
  419   2                      default:break;
  420   2              }
  421   1      }
  422          
  423          
  424          /*
  425          u8 ReadPWMA(u8 addr)    //异步读取PWMA特殊功能寄存器函数
  426          {
  427                  u8 dat;
  428                  
  429                  while (HSPWMA_ADR &     0x80); //等待前一个异步读写完成
  430                  HSPWMA_ADR = addr |     0x80;  //设置间接访问地址,只需要设置原XFR地址的低7位
  431                                                                          //HSPWMA_ADDR寄存器的最高位写1,表示读数据
  432                  while (HSPWMA_ADR &     0x80); //等待当前异步读取完成
  433                  dat     = HSPWMA_DAT;              //读取异步数据
  434                  
  435                  return dat;
  436          }
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 8   

  437          
  438          u8 ReadPWMB(u8 addr)    //异步读取PWMB特殊功能寄存器函数
  439          {
  440                  u8 dat;
  441                  
  442                  while (HSPWMB_ADR &     0x80); //等待前一个异步读写完成
  443                  HSPWMB_ADR = addr |     0x80;  //设置间接访问地址,只需要设置原XFR地址的低7位
  444                                                                          //HSPWMB_ADDR寄存器的最高位写1,表示读数据
  445                  while (HSPWMB_ADR &     0x80); //等待当前异步读取完成
  446                  dat     = HSPWMB_DAT;              //读取异步数据
  447                  
  448                  return dat;
  449          }
  450          
  451          void WritePWMA(u8 addr, u8 dat) //异步读取PWMA特殊功能寄存器函数
  452          {
  453                  while (HSPWMA_ADR &     0x80); //等待前一个异步读写完成
  454                  HSPWMA_DAT = dat;                  //准备需要写入的数据
  455                  HSPWMA_ADR = addr &     0x7f;  //设置间接访问地址,只需要设置原XFR地址的低7位
  456                                                                          //HSPWMA_ADDR寄存器的最高位写0,表示写数据
  457          }
  458          
  459          void WritePWMB(u8 addr, u8 dat) //异步读取PWMB特殊功能寄存器函数
  460          {
  461                  while (HSPWMB_ADR &     0x80); //等待前一个异步读写完成
  462                  HSPWMB_DAT = dat;                  //准备需要写入的数据
  463                  HSPWMB_ADR = addr &     0x7f;  //设置间接访问地址,只需要设置原XFR地址的低7位
  464                                                                          //HSPWMB_ADDR寄存器的最高位写0,表示写数据
  465          }
  466          
  467          void HSPWM_Configuration(u8 PWM, HSPWMx_InitDefine *PWMx, PWMx_Duty *DUTYx)     //HSPWM初始化程序
  468          {
  469                  u8 tmpENO,tmpCCER1,tmpCCER2;
  470                  
  471                  if(PWM == PWMA)
  472                  {
  473                          HSPWMA_CFG = 0x03;                      //使能PWMA相关寄存器异步访问功能
  474          
  475                          if(PWMx->PWM_EnoSelect & ENO1P)
  476                          {
  477                                  tmpENO |= ENO1P;
  478                                  tmpCCER1 |= 0x01;
  479                          }
  480                          else
  481                          {
  482                                  tmpENO &= ~ENO1P;
  483                                  tmpCCER1 &= ~0x01;
  484                          }
  485                          if(PWMx->PWM_EnoSelect & ENO1N)
  486                          {
  487                                  tmpENO |= ENO1N;
  488                                  tmpCCER1 |= 0x04;
  489                          }
  490                          else
  491                          {
  492                                  tmpENO &= ~ENO1N;
  493                                  tmpCCER1 &= ~0x04;
  494                          }
  495                          if(PWMx->PWM_EnoSelect & ENO2P)
  496                          {
  497                                  tmpENO |= ENO2P;
  498                                  tmpCCER1 |= 0x10;
  499                          }
  500                          else
  501                          {
  502                                  tmpENO &= ~ENO2P;
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 9   

  503                                  tmpCCER1 &= ~0x10;
  504                          }
  505                          if(PWMx->PWM_EnoSelect & ENO2N)
  506                          {
  507                                  tmpENO |= ENO2N;
  508                                  tmpCCER1 |= 0x40;
  509                          }
  510                          else
  511                          {
  512                                  tmpENO &= ~ENO2N;
  513                                  tmpCCER1 &= ~0x40;
  514                          }
  515                          if(PWMx->PWM_EnoSelect & ENO3P)
  516                          {
  517                                  tmpENO |= ENO3P;
  518                                  tmpCCER2 |= 0x01;
  519                          }
  520                          else
  521                          {
  522                                  tmpENO &= ~ENO3P;
  523                                  tmpCCER2 &= ~0x01;
  524                          }
  525                          if(PWMx->PWM_EnoSelect & ENO3N)
  526                          {
  527                                  tmpENO |= ENO3N;
  528                                  tmpCCER2 |= 0x04;
  529                          }
  530                          else
  531                          {
  532                                  tmpENO &= ~ENO3N;
  533                                  tmpCCER2 &= ~0x04;
  534                          }
  535                          if(PWMx->PWM_EnoSelect & ENO4P)
  536                          {
  537                                  tmpENO |= ENO4P;
  538                                  tmpCCER2 |= 0x10;
  539                          }
  540                          else
  541                          {
  542                                  tmpENO &= ~ENO4P;
  543                                  tmpCCER2 &= ~0x10;
  544                          }
  545                          if(PWMx->PWM_EnoSelect & ENO4N)
  546                          {
  547                                  tmpENO |= ENO4N;
  548                                  tmpCCER2 |= 0x40;
  549                          }
  550                          else
  551                          {
  552                                  tmpENO &= ~ENO4N;
  553                                  tmpCCER2 &= ~0x40;
  554                          }
  555                          
  556                          //通过异步方式设置PWMA的相关寄存器
  557                          WritePWMA((u8)&PWMA_CCER1, 0x00);
  558                          WritePWMA((u8)&PWMA_CCER2, 0x00);
  559                          WritePWMA((u8)&PWMA_CCMR1, CCMRn_PWM_MODE1);                            //通道模式配置
  560                          WritePWMA((u8)&PWMA_CCMR2, CCMRn_PWM_MODE1);
  561                          WritePWMA((u8)&PWMA_CCMR3, CCMRn_PWM_MODE1);
  562                          WritePWMA((u8)&PWMA_CCMR4, CCMRn_PWM_MODE1);
  563                          WritePWMA((u8)&PWMA_CCER1, tmpCCER1);                                           //配置通道输出使能和极性
  564                          WritePWMA((u8)&PWMA_CCER2, tmpCCER2);
  565                          WritePWMA((u8)&PWMA_ENO, tmpENO);                                                       //使能PWM信号输出端口
  566                          WritePWMA((u8)&PWMA_CCR1H, (u8)(DUTYx->PWM1_Duty >> 8));        //设置输出PWM的占空比
  567                          WritePWMA((u8)&PWMA_CCR1L, (u8)DUTYx->PWM1_Duty);
  568                          WritePWMA((u8)&PWMA_CCR2H, (u8)(DUTYx->PWM2_Duty >> 8));        //设置输出PWM的占空比
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 10  

  569                          WritePWMA((u8)&PWMA_CCR2L, (u8)DUTYx->PWM2_Duty);
  570                          WritePWMA((u8)&PWMA_CCR3H, (u8)(DUTYx->PWM3_Duty >> 8));        //设置输出PWM的占空比
  571                          WritePWMA((u8)&PWMA_CCR3L, (u8)DUTYx->PWM3_Duty);
  572                          WritePWMA((u8)&PWMA_CCR4H, (u8)(DUTYx->PWM4_Duty >> 8));        //设置输出PWM的占空比
  573                          WritePWMA((u8)&PWMA_CCR4L, (u8)DUTYx->PWM4_Duty);
  574                          WritePWMA((u8)&PWMA_ARRH, (u8)(PWMx->PWM_Period >> 8));         //设置输出PWM的周期
  575                          WritePWMA((u8)&PWMA_ARRL, (u8)(PWMx->PWM_Period));
  576                          WritePWMA((u8)&PWMA_DTR, PWMx->PWM_DeadTime);                           //设置互补对称输出PWM的死区
  577                          WritePWMA((u8)&PWMA_BRK, PWMx->PWM_MainOutEnable<<7);           //使能主输出
  578                          WritePWMA((u8)&PWMA_CR1, PWMx->PWM_CEN_Enable);                         //开始PWM计数
  579                  }
  580                  else if(PWM == PWMB)
  581                  {
  582                          HSPWMB_CFG = 0x03;                      //使能PWMB相关寄存器异步访问功能
  583          
  584                          if(PWMx->PWM_EnoSelect & ENO5P)
  585                          {
  586                                  tmpENO |= ENO5P;
  587                                  tmpCCER1 |= 0x01;
  588                          }
  589                          else
  590                          {
  591                                  tmpENO &= ~ENO5P;
  592                                  tmpCCER1 &= ~0x01;
  593                          }
  594                          if(PWMx->PWM_EnoSelect & ENO6P)
  595                          {
  596                                  tmpENO |= ENO6P;
  597                                  tmpCCER1 |= 0x10;
  598                          }
  599                          else
  600                          {
  601                                  tmpENO &= ~ENO6P;
  602                                  tmpCCER1 &= ~0x10;
  603                          }
  604                          if(PWMx->PWM_EnoSelect & ENO7P)
  605                          {
  606                                  tmpENO |= ENO7P;
  607                                  tmpCCER2 |= 0x01;
  608                          }
  609                          else
  610                          {
  611                                  tmpENO &= ~ENO7P;
  612                                  tmpCCER2 &= ~0x01;
  613                          }
  614                          if(PWMx->PWM_EnoSelect & ENO8P)
  615                          {
  616                                  tmpENO |= ENO8P;
  617                                  tmpCCER2 |= 0x10;
  618                          }
  619                          else
  620                          {
  621                                  tmpENO &= ~ENO8P;
  622                                  tmpCCER2 &= ~0x10;
  623                          }
  624                          
  625                          //通过异步方式设置PWMA的相关寄存器
  626                          WritePWMB((u8)&PWMB_CCER1, 0x00);
  627                          WritePWMB((u8)&PWMB_CCER2, 0x00);
  628                          WritePWMB((u8)&PWMB_CCMR1, CCMRn_PWM_MODE1);                            //通道模式配置
  629                          WritePWMB((u8)&PWMB_CCMR2, CCMRn_PWM_MODE1);
  630                          WritePWMB((u8)&PWMB_CCMR3, CCMRn_PWM_MODE1);
  631                          WritePWMB((u8)&PWMB_CCMR4, CCMRn_PWM_MODE1);
  632                          WritePWMB((u8)&PWMB_CCER1, tmpCCER1);                                           //配置通道输出使能和极性
  633                          WritePWMB((u8)&PWMB_CCER2, tmpCCER2);
  634                          WritePWMB((u8)&PWMB_ENO, tmpENO);                                                       //使能PWM信号输出端口
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 11  

  635                          WritePWMB((u8)&PWMB_CCR5H, (u8)(DUTYx->PWM5_Duty >> 8));        //设置输出PWM的占空比
  636                          WritePWMB((u8)&PWMB_CCR5L, (u8)DUTYx->PWM5_Duty);
  637                          WritePWMB((u8)&PWMB_CCR6H, (u8)(DUTYx->PWM6_Duty >> 8));        //设置输出PWM的占空比
  638                          WritePWMB((u8)&PWMB_CCR6L, (u8)DUTYx->PWM6_Duty);
  639                          WritePWMB((u8)&PWMB_CCR7H, (u8)(DUTYx->PWM7_Duty >> 8));        //设置输出PWM的占空比
  640                          WritePWMB((u8)&PWMB_CCR7L, (u8)DUTYx->PWM7_Duty);
  641                          WritePWMB((u8)&PWMB_CCR8H, (u8)(DUTYx->PWM8_Duty >> 8));        //设置输出PWM的占空比
  642                          WritePWMB((u8)&PWMB_CCR8L, (u8)DUTYx->PWM8_Duty);
  643                          WritePWMB((u8)&PWMB_ARRH, (u8)(PWMx->PWM_Period >> 8));         //设置输出PWM的周期
  644                          WritePWMB((u8)&PWMB_ARRL, (u8)(PWMx->PWM_Period));
  645                          WritePWMB((u8)&PWMB_DTR, PWMx->PWM_DeadTime);                           //设置互补对称输出PWM的死区
  646                          WritePWMB((u8)&PWMB_BRK, PWMx->PWM_MainOutEnable<<7);           //使能主输出
  647                          WritePWMB((u8)&PWMB_CR1, PWMx->PWM_CEN_Enable);                         //开始PWM计数
  648                  }
  649          }
  650          
  651          void UpdateHSPwm(u8 PWM, PWMx_Duty *PWMx)       //HSPWM占空比更新程序
  652          {
  653                  switch(PWM)
  654                  {
  655                          case PWM1:
  656                                  WritePWMA((u8)&PWMA_CCR1H, (u8)(PWMx->PWM1_Duty >> 8)); //设置输出PWM的占空比
  657                                  WritePWMA((u8)&PWMA_CCR1L, (u8)PWMx->PWM1_Duty);
  658                                  break;
  659                          case PWM2:
  660                                  WritePWMA((u8)&PWMA_CCR2H, (u8)(PWMx->PWM2_Duty >> 8)); //设置输出PWM的占空比
  661                                  WritePWMA((u8)&PWMA_CCR2L, (u8)PWMx->PWM2_Duty);
  662                                  break;
  663                          case PWM3:
  664                                  WritePWMA((u8)&PWMA_CCR3H, (u8)(PWMx->PWM3_Duty >> 8)); //设置输出PWM的占空比
  665                                  WritePWMA((u8)&PWMA_CCR3L, (u8)PWMx->PWM3_Duty);
  666                                  break;
  667                          case PWM4:
  668                                  WritePWMA((u8)&PWMA_CCR4H, (u8)(PWMx->PWM4_Duty >> 8)); //设置输出PWM的占空比
  669                                  WritePWMA((u8)&PWMA_CCR4L, (u8)PWMx->PWM4_Duty);
  670                                  break;
  671                          case PWM5:
  672                                  WritePWMB((u8)&PWMB_CCR5H, (u8)(PWMx->PWM5_Duty >> 8)); //设置输出PWM的占空比
  673                                  WritePWMB((u8)&PWMB_CCR5L, (u8)PWMx->PWM5_Duty);
  674                                  break;
  675                          case PWM6:
  676                                  WritePWMB((u8)&PWMB_CCR6H, (u8)(PWMx->PWM6_Duty >> 8)); //设置输出PWM的占空比
  677                                  WritePWMB((u8)&PWMB_CCR6L, (u8)PWMx->PWM6_Duty);
  678                                  break;
  679                          case PWM7:
  680                                  WritePWMB((u8)&PWMB_CCR7H, (u8)(PWMx->PWM7_Duty >> 8)); //设置输出PWM的占空比
  681                                  WritePWMB((u8)&PWMB_CCR7L, (u8)PWMx->PWM7_Duty);
  682                                  break;
  683                          case PWM8:
  684                                  WritePWMB((u8)&PWMB_CCR8H, (u8)(PWMx->PWM8_Duty >> 8)); //设置输出PWM的占空比
  685                                  WritePWMB((u8)&PWMB_CCR8L, (u8)PWMx->PWM8_Duty);
  686                                  break;
  687                          case PWMA:
  688                                  WritePWMA((u8)&PWMA_CCR1H, (u8)(PWMx->PWM1_Duty >> 8)); //设置输出PWM的占空比
  689                                  WritePWMA((u8)&PWMA_CCR1L, (u8)PWMx->PWM1_Duty);
  690                                  WritePWMA((u8)&PWMA_CCR2H, (u8)(PWMx->PWM2_Duty >> 8)); //设置输出PWM的占空比
  691                                  WritePWMA((u8)&PWMA_CCR2L, (u8)PWMx->PWM2_Duty);
  692                                  WritePWMA((u8)&PWMA_CCR3H, (u8)(PWMx->PWM3_Duty >> 8)); //设置输出PWM的占空比
  693                                  WritePWMA((u8)&PWMA_CCR3L, (u8)PWMx->PWM3_Duty);
  694                                  WritePWMA((u8)&PWMA_CCR4H, (u8)(PWMx->PWM4_Duty >> 8)); //设置输出PWM的占空比
  695                                  WritePWMA((u8)&PWMA_CCR4L, (u8)PWMx->PWM4_Duty);
  696                                  break;
  697                          case PWMB:
  698                                  WritePWMB((u8)&PWMB_CCR5H, (u8)(PWMx->PWM5_Duty >> 8)); //设置输出PWM的占空比
  699                                  WritePWMB((u8)&PWMB_CCR5L, (u8)PWMx->PWM5_Duty);
  700                                  WritePWMB((u8)&PWMB_CCR6H, (u8)(PWMx->PWM6_Duty >> 8)); //设置输出PWM的占空比
C251 COMPILER V5.60.0,  STC32G_PWM                                                         13/07/23  20:54:57  PAGE 12  

  701                                  WritePWMB((u8)&PWMB_CCR6L, (u8)PWMx->PWM6_Duty);
  702                                  WritePWMB((u8)&PWMB_CCR7H, (u8)(PWMx->PWM7_Duty >> 8)); //设置输出PWM的占空比
  703                                  WritePWMB((u8)&PWMB_CCR7L, (u8)PWMx->PWM7_Duty);
  704                                  WritePWMB((u8)&PWMB_CCR8H, (u8)(PWMx->PWM8_Duty >> 8)); //设置输出PWM的占空比
  705                                  WritePWMB((u8)&PWMB_CCR8L, (u8)PWMx->PWM8_Duty);
  706                                  break;
  707                          default:break;
  708                  }
  709          }
  710          */
  711          /*********************************************************/


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2316     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        32          9
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
